<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>dpki-ultralite/keypair.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Keypair.html">Keypair</a><ul class='methods'><li data-type='method'><a href="Keypair.html#.fromBundle">fromBundle</a></li><li data-type='method'><a href="Keypair.html#.newFromSeed">newFromSeed</a></li><li data-type='method'><a href="Keypair.html#decrypt">decrypt</a></li><li data-type='method'><a href="Keypair.html#encrypt">encrypt</a></li><li data-type='method'><a href="Keypair.html#getBundle">getBundle</a></li><li data-type='method'><a href="Keypair.html#getId">getId</a></li><li data-type='method'><a href="Keypair.html#sign">sign</a></li><li data-type='method'><a href="Keypair.html#verify">verify</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-dpki-ultralite.html">dpki-ultralite</a></li><li><a href="module-hClient.html">hClient</a><ul class='methods'><li data-type='method'><a href="module-hClient.html#.getCurrentAgentId">getCurrentAgentId</a></li><li data-type='method'><a href="module-hClient.html#.getDnaForUrl">getDnaForUrl</a></li><li data-type='method'><a href="module-hClient.html#.getHostsForUrl">getHostsForUrl</a></li><li data-type='method'><a href="module-hClient.html#.installLoginDialog">installLoginDialog</a></li><li data-type='method'><a href="module-hClient.html#.makeWebClient">makeWebClient</a></li><li data-type='method'><a href="module-hClient.html#.requestHosting">requestHosting</a></li><li data-type='method'><a href="module-hClient.html#.triggerLoginPrompt">triggerLoginPrompt</a></li></ul></li><li><a href="module-login.html">login</a><ul class='methods'><li data-type='method'><a href="module-login.html#~insertLoginHtml">insertLoginHtml</a></li><li data-type='method'><a href="module-login.html#~registerLoginCallbacks">registerLoginCallbacks</a></li><li data-type='method'><a href="module-login.html#~showLoginDialog">showLoginDialog</a></li></ul></li><li><a href="module-persistence.html">persistence</a></li></ul><h3>Global</h3><ul><li><a href="global.html#callSaltmine">callSaltmine</a></li><li><a href="global.html#decodeId">decodeId</a></li><li><a href="global.html#encodeId">encodeId</a></li><li><a href="global.html#fromBase64">fromBase64</a></li><li><a href="global.html#generateNewReadwriteKeypair">generateNewReadwriteKeypair</a></li><li><a href="global.html#generateReadonlyKeypair">generateReadonlyKeypair</a></li><li><a href="global.html#getLocalEntropy">getLocalEntropy</a></li><li><a href="global.html#getRegisteredSalt">getRegisteredSalt</a></li><li><a href="global.html#getRemoteEntropy">getRemoteEntropy</a></li><li><a href="global.html#pwDec">pwDec</a></li><li><a href="global.html#pwEnc">pwEnc</a></li><li><a href="global.html#pwHash">pwHash</a></li><li><a href="global.html#randomBytes">randomBytes</a></li><li><a href="global.html#regenerateReadwriteKeypair">regenerateReadwriteKeypair</a></li><li><a href="global.html#registerSalt">registerSalt</a></li><li><a href="global.html#resolverUrl">resolverUrl</a></li><li><a href="global.html#toBase64">toBase64</a></li><li><a href="global.html#verify">verify</a></li><li><a href="global.html#XorUint8Array">XorUint8Array</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">dpki-ultralite/keypair.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable */

const _sodium = require('libsodium-wrappers-sumo')
const msgpack = require('msgpack-lite')
const util = require('./util')

const NONCEBYTES = 24

/**
 * Represents two asymmetric cryptography keypairs
 * - a signing keypair
 * - an encryption keypair
 *
 * base64url encoded identity string to represent the public sides
 *
 * can optionally be initialized without the private halves of the pairs
 */
class Keypair {
  /**
   * keypair constructor (you probably want one of the static functions above)
   * @param {object} opt
   * @param {string} opt.pubkeys - the keypair identity string
   * @param {Buffer} [opt.signPriv] - private signature key
   * @param {Buffer} [opt.encPriv] - private encryption key
   */
  constructor (opt) {
    if (
      typeof opt !== 'object' ||
      typeof opt.pubkeys !== 'string'
    ) {
      throw new Error('opt.pubkeys must be a base64 encoded pubkey pair (sign / enc)')
    }
    // console.log("CHECK: ",Buffer.isBuffer(opt.encPriv));
    if (opt.signPub) {
      if (opt.signPub.constructor !== Uint8Array) {
        throw new Error('if opt.signPub is specified, it must be a Buffer')
      }
    }
    if (opt.signPriv) {
      if (opt.signPriv.constructor !== Uint8Array) {
        throw new Error('if opt.signPriv is specified, it must be a Buffer')
      }
    }

    if (opt.encPub) {
      if (opt.encPub.constructor !== Uint8Array) {
        throw new Error('if opt.encPub is specified, it must be a Buffer')
      }
    }

    if (opt.encPriv) {
      if (opt.encPriv.constructor !== Uint8Array) {
        throw new Error('if opt.encPriv is specified, it must be a Buffer')
      }
    }

    this._pubkeys = opt.pubkeys
    this._signPub = opt.signPub
    this._encPub = opt.encPub
    this._signPriv = opt.signPriv
    this._encPriv = opt.encPriv
  }

  /**
   * derive the pairs from a 32 byte seed buffer
   * @param {Buffer} seed - the seed buffer
   */
  static newFromSeed (seed) {
    return new Promise((resolve, reject) => {
      _sodium.ready.then((_) => {
        const {
          publicKey: signPub,
          privateKey: signPriv
        } = _sodium.crypto_sign_seed_keypair(seed)
        const {
          publicKey: encPub,
          privateKey: encPriv
        } = _sodium.crypto_kx_seed_keypair(seed)
        util.encodeId(signPub, encPub).then(pubkeys => {
          resolve(new Keypair({
            pubkeys,
            signPub,
            signPriv,
            encPub,
            encPriv
          }))
          reject('failure reason')
        })
      })
    })
  }

  /**
   * get the keypair identifier string
   * @return {string}
   */
  getId () {
    return this._pubkeys
  }

  /**
   * sign some arbitrary data with the signing private key
   * @param {Buffer} data - the data to sign
   */
  sign (data) {
    if (!this._signPriv) {
      throw new Error('no signPriv - cannot sign data')
    }
    return new Promise((resolve, reject) => {
      _sodium.ready.then((_) => {
        resolve(_sodium.crypto_sign_detached(data, this._signPriv))
        reject('failure reason') // rejected
      })
    })
  }

  /**
   * verify data that was signed with our private signing key
   * @param {Buffer} signature
   * @param {Buffer} data
   */
  verify (signature, data) {
    return new Promise((resolve, reject) => {
      util.verify(signature, data, this._pubkeys).then((_) => {
        resolve(_)
        reject('failure reason') // rejected
      })
    })
  }
  /**
   * encrypt arbitrary data to be readale by potentially multiple recipients
   * @param {array&lt;string>} recipientIds - multiple recipient identifier strings
   * @param {Buffer} data - the data to encrypt
   * @return {Buffer}
   */
  encrypt (recipientIds, data, adata) {
    var _this = this
    data = Buffer.from(data)

    return new Promise(function (resolve, reject) {
      _sodium.ready.then(function (_) {
        util.randomBytes(32).then(function (symSecret) {
          var out = []
          var flag = false
          return new Promise(function (resolve, reject) {
            var _loop = function _loop (i, p) {
              util.decodeId(recipientIds[i]).then(function (key) {
                return key.encPub
              }).then(function (recipPub) {
                // console.log("REC:: ",recipPub);
                var _sodium$crypto_kx_ser = _sodium.crypto_kx_server_session_keys(_this._encPub, _this._encPriv, recipPub)
                var tx = _sodium$crypto_kx_ser.sharedTx

                var nonce = _sodium.randombytes_buf(NONCEBYTES)
                var cipher = _sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(symSecret, adata || null, null, nonce, tx)
                out.push(nonce)
                out.push(cipher)
                if (i == recipientIds.length - 1) {
                  flag = true
                  resolve({
                    out: out,
                    symSecret: symSecret
                  })
                }
              })
              // XXX lru cache these so we don't have to re-gen every time?
            }

            for (var i = 0, p = Promise.resolve(); i &lt; recipientIds.length; i++) {
              _loop(i, p)
            }
          })
        }).then(function (r) {
          var out = r.out
          var symSecret = r.symSecret
          var nonce = _sodium.randombytes_buf(NONCEBYTES)
          var cipher = _sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(data, adata || null, null, nonce, symSecret)
          out.push(nonce)
          out.push(cipher)
          resolve(msgpack.encode(out))
          reject('failure reason') // rejected
        })
      })
    })
  }

  /**
   * attempt to decrypt the cipher buffer (assuming it was targeting us)
   * @param {string} sourceId - identifier string of who encrypted this data
   * @param {Buffer} cipher - the encrypted data
   * @return {Buffer} - the decrypted data
   */
  decrypt (sId, cipher, adata) {
    cipher = msgpack.decode(cipher)
    return new Promise((resolve, reject) => {
      _sodium.ready.then((_) => {
        util.decodeId(sId).then(id => {
          // we will call the encryptor the "server"
          // and the recipient (us) the "client"
          // XXX cache?
          let sourceId = id.encPub
          const {
            sharedRx: rx
          } = _sodium.crypto_kx_client_session_keys(this._encPub, this._encPriv, sourceId)
          let symSecret = null
          for (let i = 0; i &lt; cipher.length - 2; i += 2) {
            const n = cipher[i]
            const c = cipher[i + 1]
            try {
              symSecret = _sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(null, c, adata || null, n, rx)
            } catch (e) {
              /* pass */
            }
          }
          if (!symSecret) {
            reject(new Error('could not decrypt - not a recipient?'))
          } else {
            resolve(_sodium.to_string(_sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(
              null, cipher[cipher.length - 1], adata || null, cipher[cipher.length - 2], symSecret)))
            reject('failure reason') // rejected
          }
        })
      })
    })
  }

  /**
   * generate an encrypted persistence bundle
   * @param {string} passphrase - the encryption passphrase
   * @param {string} hint - additional info / description for the bundle
   */
  getBundle (passphrase, hint) {
    if (typeof hint !== 'string') {
      throw new Error('hint must be a string')
    }

    return new Promise((resolve, reject) => {
      util.pwEnc(msgpack.encode([
        this._signPub, this._encPub,
        this._signPriv, this._encPriv
      ]), passphrase).then((data) => {
        resolve({
          type: 'hcKeypair',
          hint,
          data
        })
        reject('failure reason') // rejected
      })
    })
  }

  /**
   * initialize the pairs from an encrypted persistence bundle
   * @param {object} bundle - persistence info
   * @param {string} passphrase - decryption passphrase
   */
  static fromBundle (bundle, passphrase) {
    return new Promise((resolve, reject) => {
      util.pwDec(bundle.data, passphrase).then((encoded_bundle) => {
        bundle = msgpack.decode(encoded_bundle)
        util.encodeId(bundle[0], bundle[1]).then(pubkeys => {
          resolve(new Keypair({
            pubkeys,
            signPub: bundle[0],
            signPriv: bundle[2],
            encPub: bundle[1],
            encPriv: bundle[3]
          }))
          reject('failure reason')
        })
      })
    })
  }
}
exports.Keypair = Keypair
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Mar 06 2019 12:37:28 GMT+1100 (AEDT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
